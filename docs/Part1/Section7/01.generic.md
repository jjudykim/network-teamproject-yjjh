### 🔹 **제네릭이 필요한 이유**

---

- 다양한 자료형을 다루는 자료구조를 매번 새로 만드는 것은 비효율적임

  예) `MyIntList`, `MyFloatList`, `MyShortList`, `MyMonsterList` 등 각각 별도 정의 → 비효율

- 모든 타입을 `object`로 처리하면 가능하지만, **박싱(Boxing)과 언박싱(Unboxing)** 때문에 성능이 나쁨
    - 값 타입(int 등) → 참조 타입(object) 변환 시 힙 메모리 할당 필요,
    - 언박싱 시 다시 스택으로 복사됨

  → **비효율적!**

<br>
<br>

### 🔹 **제네릭(Generic)의 개념**

---

- 클래스나 함수가 **타입에 독립적**으로 동작하도록 만드는 문법
- `<>` 꺽쇠 안에 **타입 매개변수 `T`** 사용
- 실제 사용 시에는 `int`, `float`, `Monster` 등 실제 타입으로 치환됨

```csharp
class MyList<T>
{
    T[] arr = new T[10];

    public T GetItem(int i)
    {
        return arr[i];
    }
}
```

**사용 예시**

```csharp
MyList<int> intList = new MyList<int>();
MyList<Monster> monsterList = new MyList<Monster>();
int num = intList.GetItem(0);
```

<br>
<br>

### 🔹 **함수에 제네릭 적용**

---

- 클래스뿐 아니라 **함수도 제네릭**으로 만들 수 있음.
- 함수가 어떤 타입이든 받아서 동일한 로직으로 처리할 수 있도록 설계 가능.

```csharp
static void Test<T>(T input)
{
    Console.WriteLine(input);
}
```

- `Test<int>(3);`, `Test<string>("Hello");` 모두 가능

<br>
<br>

### 🔹 **다중 제네릭 타입**

---

- 여러 타입을 동시에 받을 수도 있음.
- 대표적인 예: `Dictionary<TKey, TValue>`

```csharp
Dictionary<int, string> dict = new Dictionary<int, string>();
dict.Add(1, "Apple");
```

→ 키와 값 각각 제네릭으로 설정 가능

예) `Dictionary<int, Monster> dic = new Dictionary<int, Monster>();`

<br>
<br>

### 🔹 **제네릭 제약 조건 (Constraints)**

---

- 제네릭이 모든 타입을 받도록 설계되어 있지만, 때로는 특정 타입에 **제한을 걸어야 할 필요**가 있음.
- 이럴 때 사용하는 게 `where` 제약 조건임.

```csharp
class MyList<T> where T : Monster        // T는 Monster 또는 그 자식 클래스여야 함
class MyList<T> where T : class          // T는 참조 타입이어야 함
class MyList<T> where T : struct         // T는 값 타입이어야 함
class MyList<T> where T : new()          // T는 기본 생성자가 필요함
```

<br>
<br>

### 📌 **추가 팁**

---

- C#의 제네릭은 **컴파일 타임에 타입이 결정되기 때문에 빠르고 안정적**임.
- C++의 템플릿과 유사하지만, C#은 **런타임 제약 조건(where)** 이 가능하다는 점이 차이점임.
- 실무에서는 컬렉션(List, Dictionary, Queue 등)과 함께 자주 쓰임.