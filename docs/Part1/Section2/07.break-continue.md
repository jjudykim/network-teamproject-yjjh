## break문

### 🔹 **Break문 개요**

---

- `for문`, `while문`, `switch문`에서 즉시 반복문을 종료하는 역할.
- 특정 조건이 만족되면 반복문을 빠져나와서 다음 코드 실행.
- 무한 루프 방지, 불필요한 연산 최소화 등의 용도로 사용.

<br>
<br>

### 🔹 **Break문 기본 문법**

---

```csharp
while (true)  // 무한 루프
{
    break;  // 즉시 루프 종료
}
```

```csharp
for (int i = 0; i < 1000; ++i)
{
    if (조건)
        break;  // 특정 조건 만족 시 즉시 탈출
}
```

- `while (true)`처럼 종료 조건이 없는 루프에서도 **조건문 + break** 조합으로 제어 가능.
- `for문`에서도 특정 조건이 만족되면 즉시 탈출할 수 있음.

<br>
<br>

### 🔹 **Break문의 활용: 소수 판별 알고리즘**

---

✅ **소수(Prime Number) 판별 개념**

- **소수**: 1과 자기 자신으로만 나누어지는 수. 예) `2, 3, 5, 7, 11, 13, 17, 19, 23, ...`
- **소수가 아닌 수(합성수)**: 다른 수로 나누어 떨어짐. 예)`4` → `2 × 2`, `6` → `2 × 3`, `10` → `2 × 5`

**소수 판별 코드 (break문 적용)**

```csharp
int num = 97;
bool isPrime = true;  // 기본값: 소수(true) 가정

for (int i = 2; i < num; ++i)
{
    if ((num % i) == 0)  // 나머지가 0이면 소수가 아님
    {
        isPrime = false;
        break;  // 더 이상 검사할 필요 없음 → 즉시 탈출
    }
}

if (isPrime)
    Console.WriteLine("소수입니다!");
else
    Console.WriteLine("소수가 아닙니다!");
```
<br>
<br>

### 🔹 **Break문을 사용한 최적화**

---

⏩ **Break문이 없는 경우 (비효율적)**

```csharp
int num = 100002;
for (int i = 2; i < num; ++i)
{
    if ((num % i) == 0)
        Console.WriteLine("소수가 아닙니다!");
}
```

✅ **문제점**

- `num`이 2로 나누어 떨어지면 이미 소수가 아님이 확정됨.
- 그럼에도 불구하고 나머지 숫자들도 계속 검사 → 불필요한 연산 발생.

⏩ **Break문을 사용한 최적화 (효율적)**

```csharp
for (int i = 2; i < num; ++i)
{
    if ((num % i) == 0)
    {
        Console.WriteLine("소수가 아닙니다!");
        break;  // 불필요한 연산 중단
    }
}
```

✅ **장점**

- 첫 번째 약수가 발견되는 즉시 루프 탈출 → 연산량 감소.
- **큰 수일수록 속도 차이 극명**.

<br>
<br>

### 🔹 **Break문 사용 시 주의할 점**

---

1️⃣ **Break는 바로 직전의 블록을 탈출할 뿐, if문을 빠져나오지 않음**

```csharp
for (int i = 0; i < 10; ++i)
{
    if (i == 5)
        break;  // 반복문 탈출 (if문 탈출이 아님)

    Console.WriteLine(i);
}
```

⏩ 출력 결과:

```
0
1
2
3
4
```

✅ **for문이 종료되었음을 확인할 것!**

2️⃣ **Break문은 switch문에서도 사용 가능**

```csharp
int number = 2;
switch (number)
{
    case 1:
        Console.WriteLine("1입니다.");
        break;
    case 2:
        Console.WriteLine("2입니다.");
        break;  // break 없으면 다음 case 실행됨 (Fall-through 방지)
    default:
        Console.WriteLine("기본값입니다.");
        break;
}
```

⏩ **break 없으면 다음 case까지 실행됨** → 필요 시 반드시 추가!

<br>
<br>

### 📌 **정리**

---

- `break`는 반복문 (`for`, `while`, `switch`)에서 **즉시 탈출**하는 기능.
- **불필요한 연산 최소화**에 필수적 → 성능 향상.
- 특정 조건을 만족하면 **즉시 종료**하여 불필요한 루프 실행 방지.
- if문을 탈출하는 것이 아니라, **반복문 또는 switch문을 탈출**하는 것임.

<br>
<br>
<br>

## continue문

### 🔹 **Continue문 개요**

---

- `for문`, `while문` 등 반복문에서 특정 조건을 만족하면 현재 루프의 나머지 부분을 건너뛰고 다음 루프로 진행.
- `break`문과의 차이점:
    - `break` → 반복문을 완전히 탈출.
    - `continue` → 특정 루프를 건너뛰고 다음 반복 실행.

<br>
<br>

### 🔹 **Continue문 기본 문법**

---

```csharp
for (int i = 1; i <= 10; ++i)
{
    if (i % 3 == 0)
        continue;  // 3의 배수는 출력하지 않음

    Console.WriteLine(i);
}
```

✅ **출력 결과**:

```
1
2
4
5
7
8
10
```

→ 3, 6, 9는 출력되지 않음 (`continue`로 인해 `Console.WriteLine(i);` 실행 X).

<br>
<br>

### 🔹 **Continue문의 실행 흐름**

---

```csharp
for (int i = 1; i <= 100; ++i)
{
    if (i % 3 != 0)
        continue;  // 3의 배수가 아니면 다음 루프로 바로 이동

    Console.WriteLine($"3으로 나뉘는 숫자 발견: {i}");
}
```

1️⃣ `i = 1` → `1 % 3 != 0` → `continue` → **아래 코드 실행 안 함**

2️⃣ `i = 2` → `2 % 3 != 0` → `continue` → **아래 코드 실행 안 함**

3️⃣ `i = 3` → `3 % 3 == 0` → `Console.WriteLine` 실행

⏩ **3, 6, 9, 12, … 출력됨**

<br>
<br>

### 🔹 **Continue문 vs if문 비교**

---

⏩ **Continue문 없이 구현한 코드**

```csharp
for (int i = 1; i <= 100; ++i)
{
    if (i % 3 == 0)
        Console.WriteLine($"3으로 나뉘는 숫자 발견: {i}");
}
```

⏩ **Continue문을 사용한 코드**

```csharp
for (int i = 1; i <= 100; ++i)
{
    if (i % 3 != 0)
        continue;  // 조건을 만족하지 않으면 다음 반복으로 이동

    Console.WriteLine($"3으로 나뉘는 숫자 발견: {i}");
}
```

✅ **차이점**

- `continue`문을 사용하면 **필요한 경우만 실행하는 구조**로 변환됨.
- 복잡한 조건문(`if`)을 줄일 수 있어 **가독성이 향상**됨.

<br>
<br>

### 🔹 **Continue문 활용 예제**

---

✅ **MMORPG에서 파티원에게만 버프 적용**

```csharp
foreach (var player in players)
{
    if (!player.IsPartyMember)  // 파티원이 아니라면 다음 루프로 이동
        continue;

    player.ApplyBuff();
}
```

→ `continue`를 사용하면 **불필요한 else 문 없이** 코드를 간결하게 작성 가능.

<br>
<br>

### 🔹 **Continue문 사용 시 주의할 점**

---

1️⃣ **반복문을 벗어나지 않음**

```csharp
for (int i = 1; i <= 5; ++i)
{
    if (i == 3)
        continue;

    Console.WriteLine(i);
}
```

✅ **출력 결과**:

```
1
2
4
5
```

- `i == 3`일 때 `continue` → **출력 X** → 하지만 루프는 계속 진행됨.

2️⃣ **무한 루프 주의**

```csharp
int i = 0;
while (i < 5)
{
    if (i == 2)
        continue;  // i가 증가하지 않아서 무한 루프 발생

    Console.WriteLine(i);
    i++;
}
```

✅ **문제점**

- `i == 2`일 때 `continue`를 만나면 `i++`이 실행되지 않음.
- `i == 2`에서 계속 반복 → **무한 루프 발생**.
- 해결법: `continue` 전에 `i++`을 포함하거나 구조 변경.

✅ **올바른 코드**

```csharp
int i = 0;
while (i < 5)
{
    i++;
    if (i == 2)
        continue;

    Console.WriteLine(i);
}
```

⏩ `i++`을 먼저 실행하여 무한 루프 방지.

<br>
<br>

### 📌 **정리**

---

- `continue`문은 특정 조건을 만족하면 **현재 루프의 나머지 부분을 건너뛰고 다음 반복 실행**.
- **`break`와 달리 반복문 자체는 종료되지 않음**.
- **가독성 향상**, **복잡한 if문 제거** 등의 장점이 있음.
- 반복문 내 `continue` 사용 시 **무한 루프 발생 가능성** 주의해야 함.