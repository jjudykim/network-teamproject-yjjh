# 자료구조와 알고리즘을 들어가기 전에 ...

### 🔹 Big-O 표기법

---

- 알고리즘의 성능(효율)을 분석하기 위한 표기법
- 연산 속도(시간 복잡도)나 메모리 사용량(공간 복잡도)을 수치화하여 표현
- 알고리즘의 '절대적 실행 시간'이 아닌 '입력 크기 N에 따라 연산량이 어떻게 증가하는지'를 나타냄

**Big-O 표기법이 왜 필요한가?**

- "A가 B보다 조금 빠름" → 애매
- 실행 시간 측정? → 하드웨어/환경에 따라 달라짐
- 입력이 작을 땐 A가 빠르고, 클 땐 B가 빠른 경우도 있음
- **입력 크기 N에 따라 증가하는 연산량**을 정량적으로 비교할 수 있어야 함

  → 이를 위해 Big-O 표기법 사용


### 🔹 Big-O 분석 1단계: **연산 수 대략 계산**

---

🔹 연산 수는 **산술, 대입, 비교 연산** 등을 기준으로 판단함

```csharp
public int Add(int N) {
    return N + N;
}
// ➜ 연산 1회 ➜ O(1)
```

```csharp
public int Add2(int N) {
    int sum = 0;
    for (int i = 0; i < N; ++i)
        sum += i;
    return sum;
}
// ➜ 대입 1 + 덧셈 N회 ➜ O(N)
```

```csharp
public int Add3(int N) {
    int sum = 0;
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N; ++j)
            sum += 1;
    return sum;
}
// ➜ 대입 1 + 이중 루프 N^2 ➜ O(N^2)
```

### 🔹 Big-O 분석 2단계: **대장만 남기기**

---

- **규칙 1**: 영향력이 가장 큰 항만 남김
- **규칙 2**: 상수는 무시 (예: 2N → N)

```csharp
public int Add4(int N) {
    int sum = 0;                        // +1
    for (int i = 0; i < N; ++i)        // +N
        sum += i;
    for (int i = 0; i < 2 * N; ++i)
        for (int j = 0; j < 2 * N; ++j)
            sum += 1;                  // +4N^2
    sum += 1234567;                    // +1
    return sum;
}

// 총 연산량: 1 + N + 4N^2 + 1
// ➜ 영향력 큰 항: 4N^2
// ➜ 상수 제거: O(N^2)
```

- `O`는 "Order of"의 약자
- O(N), O($N^2$), O(log N) 등으로 표현함

### 🔹 Big-O 함수별 증가 속도 비교

---

입력 크기 `N`이 커질수록 알고리즘 성능은 다음과 같은 속도 차이를 보임:

| 함수 | 연산량 증가 속도 | 설명 |
| --- | --- | --- |
| O(1) | 매우 느림 | 상수 시간 (입력과 무관) |
| O(log N) | 느림 | 이진 탐색 등 (반씩 줄임) |
| O(N) | 중간 | 선형 검색 |
| O(N log N) | 조금 빠름 | 병합 정렬 등 |
| O($N^2$) 이상 | 매우 빠름 | 이중 반복문, 버블 정렬 등 |

✔ N이 커질수록 $N^2$, $N^3$, $2^N$ 등은 **현실적으로 사용 불가**

✔ O(1) ~ O(log N)은 매우 이상적인 성능

![image.png](image.png)

![image.png](image%201.png)

### 🔹 로그 함수 (log N)의 의미

---

**정의**

- `log₂(N)`은 "2를 몇 번 곱해야 N이 되는가?"
- 일반형: `logₐ(b)` = `?` such that `$a^?$ = b`

**예시**

- `2^1 = 2`, `2^2 = 4`, `2^3 = 8`

  → `log₂(8) = 3`


**의미**

- 이진 탐색의 시간 복잡도: O(log N)
- 데이터 양이 많아질수록 **반씩 나누며** 빠르게 줄여나감

### 🔹 예시: 업다운 게임 & 이진 탐색

---

문제: 1~100 사이에서 랜덤 숫자 맞추기

✔ 순차 탐색: **O(N)**

✔ 이진 탐색:

- 1차 시도: 50
- 2차 시도: 75
- 3차 시도: 87
- …

→ 최대 시도 횟수: log₂(N) + 1

결론: 반씩 줄이는 구조 = log N

### ✅ 결론

---

- Big-O는 "**입력 크기 N이 커질수록 얼마나 빠르게 연산량이 증가하는가**"를 보여주는 도구
- 정확한 연산 횟수보다, **증가율(성장 속도)**이 중요함
- 알고리즘 분석, 성능 비교, 면접 등에서 필수적으로 사용됨
- 주요 Big-O 종류와 의미, 로그 함수의 의미까지 알고 있으면 추후 다양한 알고리즘 분석에 유용함

```csharp
public int Add4(int N)
{
	int sum = 0;
	
	for (int i = 0; i < N; ++i)
		sum += i;
	
	for (int i = 0; i < 2 * N; ++i)
		for (int j =0; j < 2 * N; ++j)
			sum += 1;
	
	sum += 1234567;
	
	return sum;
}
```

> a ^ ? = b </br>
> ? = log_a(b)
